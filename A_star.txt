Home point H
End point B
Loop1:
current point H
add to open list of nodes
*open list is nodes to be considered
goto->Loop2
Loop2:
A = current node
if A = B:
goto->FinishedLoop
	
remove A from open list and add it to closed
look at neighbors 
ignore unwalkalbe nodes or closed list nodes
if adjacent square c is on open list:
	if adjacent c.g is > open list c.g:
		make c's parent A
		recalculate c's F,G scores
add each to open list and have A as parent
---------------------------------------
FinishedLoop:
keep going backwards through paretns until H






if not at destination, branch to Loop1 with A
what should A be?
N = node from open list with lowest F
F = G + H
G = movemetn cost from H
* take parents H and add n movement cost to it
H = estimated move cost to move from the A to B
* ((Bx-Ax + By-Ay) * n movement cost)

Summary:
1) add starting node to  ope list
2) Repeat the following:
	Look for lowest F cost square onn the open list
		*this is the current node
	put it in closed list
	for each 8 adjacet squares:
		ignore unwalkable/closed list items
		if not in open list && new node.G > N.G:
			change parent of square to N
			recalc G and F
	stop when target square is in closed list
	work backwards from target square by chaining parents






